change tests to have better comparisons against floating pointer numbers. e.g. (a - b).abs() < EPSILON

json file to read in scene description. e.g. shapes, their positions, materials, etc. the light and its properties etc.
and creates a World object from it

profile and benchmark in general to see if there are any major bottlenecks. Likely, since I'm very new to Rust.
    - make multithreaded
    	- try various ways. e.g. construct threads ourselves, use tokio, use mpsc, use rayon, etc.
    - remove unnecessary allocations
    - use caching 
    	-e.g when setting transform, pre-compute the inverse and store as new property in struct
    - precompute stuff. lookup tables etc. e.g. precompute and store all known sin() and cos() calculations we'd need for our selected transformations?
    - spatial partioning, hierarchical bounding volumes and broad + narrow phase collision detection to reduce number of intersection tests. aka "acceleration structure" in some ray tracing books
    - slice reads/writes that are making use of spatial and temporal locality. 
        e.g. test array usage in both row major and column major order, one might be faster
    - simd if we can?
    - utilize the GPU in some way - opengl compute shader seems good choice?
    - checkerboard rendering, only trace every other pixel (performance at the cost of image quality, useful for test scenes before deciding on a final large render)
    - see optimizations sections in physically-based rendering book
    - see if using fixed point numbers will increase performance
    - for normalized vectors, don't need use sqrt for some of the calculations since sqrt(1) = 1, so magnitude_squared can be used instead
    - change current phong shading for blinn-phong which is faster (or keep them both and allow it to be configurable)

support "animations". i.e. produce several frames for scenes containing dynamic objects 

png optimization. Saving it as raw png with no compression for a 10k * 10k scene = 381mb, yet opening
and saving that picture in paint.net lowers it to almost nothing! (e.g. for hello world render, went down to 53kb!!)

support multiple light sources 



add antialiasing
add shadows
add mirror, glass, metal materials
add ambient occlusion
add "combined shapes", don't know the proper technical term. Using things like a signed distance function so you can perform an 
intersection or union of multiple shapes to create new ones.
light to attenuate over distance
atmospheric scattering 

code seems to be getting too spaghetti, lots of use crate::this_thing::that_thing in almost every module